## Call germline SNPs and indels via local re-assembly of haplotypes with the GATK HaplotypeCaller
rule haplotypecaller:
    input:
        vcf=rules.retrieve_dbsnp_vcf.output.vcf,
        idx=rules.retrieve_dbsnp_vcf.output.idx,
        bam=rules.apply_bqsr.output.bam,
        bai=rules.apply_bqsr.output.bai,
        fa=rules.retrieve_reference_genome.output.fa
    output:
        vcf=paths.germline.vcf,
        idx=paths.germline.idx
    benchmark:
        'benchmark/{sample}_haplotypecaller.tab'
    log:
        'log/{sample}_haplotypecaller.log'
    conda:
        "../envs/gatk.yaml"
    threads: max(1,min(8,NCORES))
    shell:
        '''
          echo "gatk HaplotypeCaller -R {input.fa} -I {input.bam} -D {input.vcf} -stand-call-conf 30 -O {output.vcf}" | tee {log}
          gatk HaplotypeCaller -R {input.fa} -I {input.bam} -D {input.vcf} -stand-call-conf 30 -O {output.vcf} 2>> {log}
        '''

## Compress (bgzip) the output VCF from HaplotypeCaller and generate tabix for use with BCFtools filtering
rule haplotypecaller_bgzip_tabix:
    input:
        vcf=rules.haplotypecaller.output.vcf,
        idx=rules.haplotypecaller.output.idx
    output:
        gz=paths.germline.gz,
        tbi=paths.germline.gz_tbi
    benchmark:
        'benchmark/{sample}_haplotypecaller_bgzip_tbix.tab'
    log:
        'log/{sample}_haplotypecaller_bgzip_tbix.log'
    conda:
        "../envs/bcftools.yaml"
    threads: max(1,min(8,NCORES))
    shell:
        '''
          echo "bgzip -@ {threads} {input.vcf} && tabix -p vcf {output.gz}" | tee {log}
          bgzip -@ {threads} {input.vcf} && tabix -p vcf {output.gz} 2>> {log}
        '''

## Outputs the variants that are only found in the specified CIMAC Center's targets BED
rule bcftools_targets:
    input:
        vcf=rules.haplotypecaller_bgzip_tabix.output.gz,
        tbi=rules.haplotypecaller_bgzip_tabix.output.tbi,
        bed=rules.retrieve_targets_bed.output.bed
    output:
        targets=paths.germline.targets
    benchmark:
        'benchmark/{sample}_bcftools_targets.tab'
    log:
        'log/{sample}_bcftools_targets.log'
    conda:
        "../envs/bcftools.yaml"
    threads: max(1,min(8,NCORES))
    shell:
        '''
          echo "bcftools view -R {input.bed} --threads {threads} {input.vcf} | bgzip -@ {threads} -c > {output.targets}" | tee {log}
          bcftools view -R {input.bed} --threads {threads} {input.vcf} | bgzip -@ {threads} -c > {output.targets} 2>> {log}

          ## Export rule env details
          conda env export --no-builds > info/bcftools.info
        '''

## Generates tbi for the targets VCF generated by HaplotypeCaller
rule tabix_targets:
    input:
        targets=rules.bcftools_targets.output.targets,
    output:
        tbi=paths.germline.tbi
    benchmark:
        'benchmark/{sample}_tabix_targets.tab'
    log:
        'log/{sample}_tabix_targets.log'
    conda:
        "../envs/bcftools.yaml"
    shell:
        '''
          echo "tabix -p vcf {input.targets}" | tee {log}
          tabix -p vcf {input.targets} 2>> {log}
        '''

## Compare tumor and normal targets VCFs for each pairing. Tumor only samples do NOT get run with this rule
rule vcf_compare:
    input:
        tumor=rules.bcftools_targets.output.targets,
        tumor_tbi=rules.tabix_targets.output.tbi,
        normal=lambda wildcards: Path(PREDIR) / "germline" / f"{pairings_df.at[wildcards.sample,'normal']}_haplotypecaller.targets.vcf.gz" if pairings_df.at[wildcards.sample,'type'] == "TN" else [],
        normal_tbi=lambda wildcards: Path(PREDIR) / "germline" / f"{pairings_df.at[wildcards.sample,'normal']}_haplotypecaller.targets.vcf.gz.tbi" if pairings_df.at[wildcards.sample,'type'] == "TN" else []
    output:
        txt=paths.germline.txt
    benchmark:
        'benchmark/{sample}_vcf_compare.tab'
    log:
        'log/{sample}_vcf_compare.log'
    conda:
        "../envs/vcftools.yaml"
    shell:
        '''
          echo "vcf-compare {input.tumor} {input.normal} > {output.txt}" | tee {log}
          vcf-compare {input.tumor} {input.normal} > {output.txt} 2>> {log}
        '''

## Produces stats for the tumor and normal VCFs; the program generates separate stats for intersection and the complements
rule bcftools_stats:
    input:
        tumor=rules.bcftools_targets.output.targets,
        tumor_tbi=rules.tabix_targets.output.tbi,
        normal=lambda wildcards: Path(PREDIR) / "germline" / f"{pairings_df.at[wildcards.sample,'normal']}_haplotypecaller.targets.vcf.gz" if pairings_df.at[wildcards.sample,'type'] == "TN" else [],
        normal_tbi=lambda wildcards: Path(PREDIR) / "germline" / f"{pairings_df.at[wildcards.sample,'normal']}_haplotypecaller.targets.vcf.gz.tbi" if pairings_df.at[wildcards.sample,'type'] == "TN" else []
    output:
        stats=paths.germline.stats
    benchmark:
        'benchmark/{sample}_bcftools_stats.tab'
    log:
        'log/{sample}_bcftools_stats.log'
    conda:
        "../envs/bcftools.yaml"
    threads: max(1,min(8,NCORES))
    shell:
        '''
          echo "bcftools stats --threads {threads} {input.tumor} {input.normal} > {output.stats}" | tee {log}
          bcftools stats --threads {threads} {input.tumor} {input.normal} > {output.stats} 2>> {log}
        '''

## Processes output of bcftools stats by generating plots and a summary PDF
rule bcftools_plot_vcfstats:
    input:
        stats=rules.bcftools_stats.output.stats
    output:
        pdf=paths.germline.pdf
    benchmark:
        'benchmark/{sample}_bcftools_plot_vcfstats.tab'
    log:
        'log/{sample}_bcftools_plot_vcfstats.log'
    conda:
        "../envs/bcftools.yaml"
    params: 
        dir=PREDIR+"/germline/{sample}_plot_vcfstats"
    shell:
        '''
          echo "plot-vcfstats {input.stats} -p {params.dir}" | tee {log}
          plot-vcfstats {input.stats} -p {params.dir} 2>> {log}
        '''
